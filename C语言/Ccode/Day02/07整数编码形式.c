#include <stdio.h>

int main(int argc, char const *argv[])
{
    // 计算机中整数存储的是数据的补码

    /*
    - 原码：正数直接使用二进制来表达，
    
    以一个字节数据为例
    char num1 = 7;  原码 0000 0111
    char num1 = -7; 原码 1000 0111
                    原码相加1000 1110  得到 -14  发现原码做不了减法运算

    - 反码：若数字为正数原码就是反码   若数字为负数反码就是原码保留符号位其他位取反

    以一个字节数据为例
    char num1 = 7;  原码 0000 0111    反码 0000 0111
    char num1 = -7; 原码 1000 0111    反码 1111 1000
                                      反码相加1111 1111  转原码 1000 0000 得到 -0 我们发现0有两个反码0000 0000 和 1111 1111 都是0的反码
    尝试    7 和 -5 相加
                  7 原码 0000 0111   反码  0000 0111
                 -5 原码 1000 0101   反码  1111 1010    
                                     相加  0000 0001  得到 1                                 

    - 补码：若数字为正数原码就是补码  若数字为负数补码等于 反码 加 1
    7 与 -7相加
                  7 原码 0000 0111   反码  0000 0111  补码  0000 0111
                 -7 原码 1000 0111   反码  1111 1000  补码  1111 1001
                                                 补码相加   0000 0000  即 0
    7 与 -6相加
                  7 原码 0000 0111   反码  0000 0111  补码  0000 0111
                 -6 原码 1000 0110   反码  1111 1001  补码  1111 1010
                                                 补码相加   0000 0001  即 1
    6 与 -7相加
                  6 原码 0000 0110   反码  0000 0110  补码   0000 0110 
                 -7 原码 1000 0111   反码  1111 1000  补码   1111 1001
                                                 补码相加    1111 1111  转反码  1111 1110  原码   1000 0001  即 -1                                      

    - 注意负数的补码在取反加一的时候，符号位是不动的

    问补码 1000 0010 反码 1000 0001 原码 1111 1110 即 -126 
    问补码 1000 0001 反码 1000 0000 原码 1111 1111 即 -127 
    问补码 1000 0000 唯一一个只有补码没有源码反码的数字, 强制设置其为 -128 
    
    一个字节的有符号整形 hhd% 取值范围 127 ~ -128 
    
    */

    

    return 0;
}
